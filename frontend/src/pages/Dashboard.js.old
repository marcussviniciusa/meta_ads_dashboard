import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Container,
  Grid,
  Paper,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
  CircularProgress,
  Alert,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  TextField,
  InputAdornment,
  IconButton,
  Chip,
  Divider,
} from '@mui/material';
import CheckIcon from '@mui/icons-material/Check';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import DownloadIcon from '@mui/icons-material/Download';
import ShareIcon from '@mui/icons-material/Share';
import FilterAltIcon from '@mui/icons-material/FilterAlt';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import PauseCircleIcon from '@mui/icons-material/PauseCircle';
import BlockIcon from '@mui/icons-material/Block';
import HelpIcon from '@mui/icons-material/Help';
import { Line } from 'react-chartjs-2';
import { DataGrid } from '@mui/x-data-grid';
import axios from '../axiosConfig';

// Register ChartJS components
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  ArcElement,
  Filler
} from 'chart.js';
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

const datePresets = [
  { value: 'today', label: 'Hoje' },
  { value: 'yesterday', label: 'Ontem' },
  { value: 'last_3d', label: 'Últimos 3 dias' },
  { value: 'last_7d', label: 'Últimos 7 dias' },
  { value: 'last_14d', label: 'Últimos 14 dias' },
  { value: 'last_28d', label: 'Últimos 28 dias' },
  { value: 'last_30d', label: 'Últimos 30 dias' },
  { value: 'last_90d', label: 'Últimos 90 dias' },
];

function Dashboard() {
  // Estados para filtros e dados
  const [bmAccounts, setBmAccounts] = useState([]);
  const [adAccounts, setAdAccounts] = useState([]);
  const [campaigns, setCampaigns] = useState([]);
  const [insights, setInsights] = useState([]);
  const [chartData, setChartData] = useState(null);
  const [ads, setAds] = useState([]); 
  const [filteredAds, setFilteredAds] = useState([]);
  const [adsLoading, setAdsLoading] = useState(false);
  const [adStatusFilter, setAdStatusFilter] = useState('ALL'); 
  
  // Estados para seleções
  const [selectedBm, setSelectedBm] = useState('');
  const [selectedAdAccount, setSelectedAdAccount] = useState('');
  const [selectedCampaign, setSelectedCampaign] = useState('');
  const [datePreset, setDatePreset] = useState('last_7d');
  const [useCustomDates, setUseCustomDates] = useState(false);
  const [startDate, setStartDate] = useState(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000));
  const [endDate, setEndDate] = useState(new Date());
  
  // Estados para UI
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [totalImpressions, setTotalImpressions] = useState(0);
  const [totalClicks, setTotalClicks] = useState(0);
  const [totalSpend, setTotalSpend] = useState(0);
  const [ctr, setCtr] = useState(0);
  const [registerBmDialog, setRegisterBmDialog] = useState(false);
  const [newBmId, setNewBmId] = useState('');
  const [newBmToken, setNewBmToken] = useState('');
  const [shareDialog, setShareDialog] = useState(false);
  const [shareLink, setShareLink] = useState('');
  const [shareExpiration, setShareExpiration] = useState(24);
  const [copied, setCopied] = useState(false);
  const [autoRefresh, setAutoRefresh] = useState(false);
  const [refreshInterval, setRefreshInterval] = useState(60);
  const [lastRefreshed, setLastRefreshed] = useState(null);
  
  // Função para preparar dados do gráfico
  const prepareChartData = useCallback((insightsData) => {
    if (!insightsData || insightsData.length === 0) return null;
    
    // Verificar se temos datas definidas nos insights
    const hasDefinedDates = insightsData.some(item => item.date_start);
    
    // Criar datas simuladas para os últimos 7 dias se não houver datas
    let dates = [];
    let sortedInsights = [...insightsData];
    
    if (!hasDefinedDates) {
      console.log('Sem datas definidas nos insights, criando datas simuladas');
      
      // Criar datas para os últimos 7 dias
      const today = new Date();
      dates = Array.from({ length: 7 }, (_, i) => {
        const date = new Date(today);
        date.setDate(today.getDate() - (6 - i));  // Últimos 7 dias, começando 6 dias atrás
        return date.toISOString().split('T')[0]; // Formato YYYY-MM-DD
      });
      
      // Se temos apenas um insight, distribuímos os valores entre as datas
      if (insightsData.length === 1) {
        const singleInsight = insightsData[0];
        sortedInsights = dates.map((date, index) => {
          // Criamos uma variação para não ter valores iguais todos os dias
          const factor = 0.7 + (index / 6) * 0.6; // Fator que vai de 0.7 a 1.3
          
          return {
            ...singleInsight,
            date_start: date,
            impressions: Math.round((parseInt(singleInsight.impressions) || 0) * factor / 7),
            clicks: Math.round((parseInt(singleInsight.clicks) || 0) * factor / 7),
            spend: ((parseFloat(singleInsight.spend) || 0) * factor / 7).toFixed(2)
          };
        });
      }
    } else {
      // Se temos datas, ordenamos normalmente
      sortedInsights.sort((a, b) => {
        return new Date(a.date_start) - new Date(b.date_start);
      });
      
      // Extrair datas únicas
      dates = [...new Set(sortedInsights.map(item => item.date_start))];
    }
    
    // Log para depuração do formato das datas
    console.log('Datas para o gráfico (após processamento):', dates);
    
    // Preparar dados para o gráfico de cliques x impressões
    const clicksData = dates.map(date => {
      const dayData = sortedInsights.find(item => item.date_start === date);
      return dayData ? dayData.clicks : 0;
    });
    
    const impressionsData = dates.map(date => {
      const dayData = sortedInsights.find(item => item.date_start === date);
      // Dividir por 1000 para escala mais adequada
      return dayData ? dayData.impressions / 1000 : 0;
    });
    
    const spendData = dates.map(date => {
      const dayData = sortedInsights.find(item => item.date_start === date);
      return dayData ? parseFloat(dayData.spend) : 0;
    });
    
    // Formatar datas para exibição no eixo X com tratamento de erros
    const formattedDates = dates.map(date => {
      try {
        // Verificar o formato da data recebida
        console.log('Processando data:', date, 'tipo:', typeof date);
        
        // Verificar se a data tem o formato ISO (YYYY-MM-DD)
        let dateObj;
        if (typeof date === 'string') {
          // Se for uma string, tentar extrair partes da data
          if (date.includes('-')) {
            // Formato ISO YYYY-MM-DD 
            dateObj = new Date(date);
          } else if (date.includes('/')) {
            // Formato MM/DD/YYYY ou DD/MM/YYYY
            const parts = date.split('/');
            if (parts.length === 3) {
              // Assumir MM/DD/YYYY para compatibilidade com API do Facebook
              dateObj = new Date(parts[2], parts[0]-1, parts[1]);
            }
          } else {
            // Tentar converter diretamente
            dateObj = new Date(date);
          }
        } else {
          // Caso não seja string, tentar converter diretamente
          dateObj = new Date(date);
        }
        
        // Verificar se a data é válida
        if (isNaN(dateObj.getTime())) {
          // Data inválida, retornar uma representação da string original
          console.error('Data inválida:', date);
          return date.toString().substring(0, 10);
        }
        
        // Formatar a data válida
        return dateObj.toLocaleDateString('pt-BR');
      } catch (error) {
        console.error('Erro ao processar data:', date, error);
        return 'Data inválida';
      }
    });
    
    // Calcular totais
    const totalImpressions = sortedInsights.reduce((sum, item) => sum + (parseInt(item.impressions) || 0), 0);
    const totalClicks = sortedInsights.reduce((sum, item) => sum + (parseInt(item.clicks) || 0), 0);
    const totalSpend = sortedInsights.reduce((sum, item) => sum + (parseFloat(item.spend) || 0), 0);
    const averageCTR = totalImpressions > 0 ? (totalClicks / totalImpressions) * 100 : 0;
    
    // Atualizar os estados com os totais
    setTotalImpressions(totalImpressions);
    setTotalClicks(totalClicks);
    setTotalSpend(totalSpend);
    setCtr(averageCTR);
    
    return {
      clicksImpressionsData: {
        labels: formattedDates,
        datasets: [
          {
            label: 'Cliques',
            data: clicksData,
            borderColor: 'rgba(54, 162, 235, 1)',
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            fill: false,
            yAxisID: 'y1',
          },
          {
            label: 'Impressões (milhares)',
            data: impressionsData,
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.5)',
            fill: false,
            yAxisID: 'y',
          }
        ]
      },
      clicksImpressionsOptions: {
        responsive: true,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        stacked: false,
        plugins: {
          title: {
            display: true,
            text: 'Cliques e Impressões'
          }
        },
        scales: {
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: {
              display: true,
              text: 'Impressões (milhares)'
            }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            grid: {
              drawOnChartArea: false,
            },
            title: {
              display: true,
              text: 'Cliques'
            }
          },
        }
      },
      spendData: {
        labels: formattedDates,
        datasets: [
          {
            label: 'Investimento (R$)',
            data: spendData,
            borderColor: 'rgba(75, 192, 192, 1)',
            backgroundColor: 'rgba(75, 192, 192, 0.5)',
            fill: true,
          }
        ]
      },
      spendOptions: {
        responsive: true,
        plugins: {
          legend: {
            position: 'top',
          },
          title: {
            display: true,
            text: 'Investimento Diário'
          }
        }
      },
      performanceData: {
        labels: formattedDates,
        datasets: [
          {
            label: 'Cliques',
            data: clicksData,
            borderColor: 'rgba(54, 162, 235, 1)',
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            borderWidth: 2,
            pointRadius: 3,
            tension: 0.3,
          },
          {
            label: 'Impressões (milhares)',
            data: impressionsData,
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.5)',
            borderWidth: 2,
            pointRadius: 3,
            tension: 0.3,
          }
        ]
      },
    };
  }, []);

  // Nova função para buscar insights (convertida para useCallback)
  const fetchInsights = useCallback(async () => {
    if (!selectedBm || !selectedAdAccount) return;
    
    setLoading(true);
    setError(null);
    
    try {
      // Preparar os parâmetros da requisição
      let params = {
        bm_id: selectedBm,
        ad_account_id: selectedAdAccount,
      };
      
      // Adicionar filtros extras se selecionados
      if (selectedCampaign) {
        params.campaign_id = selectedCampaign;
      }
      
      if (datePreset && datePreset !== 'custom') {
        params.date_preset = datePreset;
      } else if (startDate && endDate) {
        params.start_date = startDate;
        params.end_date = endDate;
      } else {
        params.date_preset = 'last_7d';  // Padrão para 7 dias
      }
      
      console.log('Fetching insights with params:', params);
      
      const response = await axios.get('/api/account-insights', { params });
      console.log('Raw insights data:', response.data);
      
      // Acessar o array insights dentro do objeto retornado
      let insightsArray = [];
      if (response.data.insights && Array.isArray(response.data.insights)) {
        insightsArray = response.data.insights;
      } else if (Array.isArray(response.data)) {
        insightsArray = response.data;
      } else if (response.data && typeof response.data === 'object') {
        // Se for um único objeto, colocá-lo em um array
        insightsArray = [response.data];
      }
      
      console.log('Insights array extracted:', insightsArray);
      
      // Atualizar o estado com os dados
      setInsights(insightsArray);
      
      // Preparar dados para os gráficos
      const chartData = prepareChartData(insightsArray);
      console.log('Prepared chart data:', chartData);
      
      setChartData(chartData);
      setLoading(false);
      setLastRefreshed(new Date());
    } catch (err) {
      console.error('Error fetching insights:', err);
      setError('Erro ao buscar insights: ' + (err.response?.data?.error || err.message));
      setLoading(false);
    }
  }, [selectedBm, selectedAdAccount, selectedCampaign, datePreset, startDate, endDate, prepareChartData]);

  // Nova função para buscar anúncios (convertida para useCallback)
  const fetchAds = useCallback(async () => {
    if (!selectedBm || !selectedAdAccount) return;
    
    setAdsLoading(true);
    setError(null);
    
    try {
      // Preparar os parâmetros da requisição
      let params = {
        bm_id: selectedBm,
        limit: 6  // Limitar a 6 anúncios para não sobrecarregar
      };
      
      // Decidir se vamos buscar por conta ou campanha
      if (selectedCampaign) {
        params.campaign_id = selectedCampaign;
      } else {
        params.ad_account_id = selectedAdAccount;
      }
      
      console.log('Fetching ads with params:', params);
      
      const response = await axios.get('/api/ads', { params });
      console.log('Ads data:', response.data);
      
      const adsData = response.data.ads || [];
      setAds(adsData);
      setFilteredAds(adsData);
      setAdsLoading(false);
    } catch (err) {
      console.error('Error fetching ads:', err);
      setError('Erro ao buscar anúncios: ' + (err.response?.data?.error || err.message));
      setAdsLoading(false);
    }
  }, [selectedBm, selectedAdAccount, selectedCampaign]);

  // Load BM accounts when component mounts
  useEffect(() => {
    fetchBmAccounts();
  }, []);

  // Efeito para atualização automática
  useEffect(() => {
    let intervalId;
    
    if (autoRefresh && selectedAdAccount) {
      intervalId = setInterval(() => {
        fetchInsights();
        setLastRefreshed(new Date());
      }, refreshInterval * 1000);
    }
    
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [autoRefresh, refreshInterval, selectedAdAccount, selectedBm, selectedCampaign, datePreset, useCustomDates, startDate, endDate, fetchInsights]);

  // Load ad accounts when BM is selected
  useEffect(() => {
    if (selectedBm) {
      fetchAdAccounts(selectedBm);
    }
  }, [selectedBm]);

  // Load campaigns when ad account is selected
  useEffect(() => {
    if (selectedAdAccount) {
      fetchCampaigns(selectedBm, selectedAdAccount);
    }
  }, [selectedBm, selectedAdAccount]);

  // Load insights when filters change
  useEffect(() => {
    if (selectedBm && (selectedAdAccount || selectedCampaign) && (datePreset || (useCustomDates && startDate && endDate))) {
      fetchInsights();
    }
  }, [selectedBm, selectedAdAccount, selectedCampaign, datePreset, useCustomDates, startDate, endDate, fetchInsights]);

  // Fetch functions
  const fetchBmAccounts = async () => {
    try {
      setLoading(true);
      const response = await axios.get('/api/bm-accounts');
      setBmAccounts(response.data.bm_accounts || []);
      setLoading(false);
      
      // Show register BM dialog if no accounts are found
      if (response.data.bm_accounts?.length === 0) {
        setRegisterBmDialog(true);
      }
    } catch (err) {
      setError('Failed to load Business Manager accounts');
      setLoading(false);
    }
  };

  const fetchAdAccounts = async (bmId) => {
    try {
      setLoading(true);
      const response = await axios.get(`/api/ad-accounts?bm_id=${bmId}`);
      setAdAccounts(response.data.ad_accounts || []);
      setSelectedAdAccount('');
      setCampaigns([]);
      setSelectedCampaign('');
      setLoading(false);
    } catch (err) {
      setError('Failed to load Ad Accounts');
      setLoading(false);
    }
  };

  const fetchCampaigns = async (bmId, adAccountId) => {
    try {
      setLoading(true);
      const response = await axios.get(`/api/campaigns?bm_id=${bmId}&ad_account_id=${adAccountId}`);
      setCampaigns(response.data.campaigns || []);
      setSelectedCampaign('');
      setLoading(false);
    } catch (err) {
      setError('Failed to load Campaigns');
      setLoading(false);
    }
  };

  // Buscar anúncios quando os insights são carregados
  useEffect(() => {
    if (insights && insights.length > 0) {
      fetchAds();
    }
  }, [insights, fetchAds]);

  const generatePdf = async () => {
    try {
      const params = {
        bm_id: selectedBm,
        ad_account_id: selectedCampaign ? null : selectedAdAccount,
        campaign_id: selectedCampaign || null,
        date_preset: useCustomDates ? `custom:${startDate.toISOString()}:${endDate.toISOString()}` : datePreset
      };
      
      const response = await axios.post('/api/generate-pdf', params, {
        responseType: 'blob'
      });
      
      // Create a blob link to download
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `report_${new Date().toISOString()}.pdf`);
      document.body.appendChild(link);
      link.click();
      
      // Clean up and remove the link
      link.parentNode.removeChild(link);
    } catch (err) {
      setError('Failed to generate PDF report');
    }
  };

  const createShareLink = async () => {
    try {
      const params = {
        bm_id: selectedBm,
        ad_account_id: selectedCampaign ? null : selectedAdAccount,
        campaign_id: selectedCampaign || null,
        date_preset: useCustomDates ? `custom:${startDate.toISOString()}:${endDate.toISOString()}` : datePreset,
        expiration: shareExpiration
      };
      
      const response = await axios.post('/api/create-share-link', params);
      setShareLink(response.data.share_link);
    } catch (err) {
      setError('Failed to create share link');
    }
  };

  const handleShareDialogOpen = () => {
    setShareLink('');
    setShareDialog(true);
  };

  const handleShareDialogClose = () => {
    setShareDialog(false);
  };

  const registerNewBm = async () => {
    if (!newBmId || !newBmToken) {
      setError('BM ID and access token are required');
      return;
    }
    
    try {
      setLoading(true);
      await axios.post('/api/register-bm', {
        bm_id: newBmId,
        access_token: newBmToken
      });
      
      // Refresh BM accounts list
      await fetchBmAccounts();
      setRegisterBmDialog(false);
      setNewBmId('');
      setNewBmToken('');
      setLoading(false);
    } catch (err) {
      setError('Failed to register Business Manager account');
      setLoading(false);
    }
  };

  // Esta área estava anteriormente dentro da função processInsightsData que foi removida      
      // Gerar fatores de variação para cada dia (entre 0.7 e 1.3)
      for (let i = 0; i < numDaysToSimulate; i++) {
        const factor = 0.7 + Math.random() * 0.6;
        variationFactors.push(factor);
        sumFactors += factor;
      }
      
      // Normalizar os fatores para garantir que a soma seja exatamente igual ao total
      const normalizedFactors = variationFactors.map(factor => factor / sumFactors * numDaysToSimulate);
      
      // Verificar se a soma dos fatores normalizados é exatamente igual ao número de dias
      const factorSum = normalizedFactors.reduce((sum, factor) => sum + factor, 0);
      console.log(`Soma dos fatores normalizados: ${factorSum.toFixed(6)}, Dias: ${numDaysToSimulate}`);
      
      // Valores acumulados para ajuste final
      let accumulatedSpend = 0;
      let accumulatedClicks = 0;
      let accumulatedImpressions = 0;
      
      // Distribuir os valores totais pelos dias com variação normalizada
      for (let i = 0; i < numDaysToSimulate; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() - (numDaysToSimulate - 1 - i));
        const dateString = date.toISOString().split('T')[0];
        
        // Usar o fator normalizado para garantir que a soma seja igual ao total
        const factor = normalizedFactors[i];
        
        // Calcular valores diários
        let dailySpend = i < numDaysToSimulate - 1 
          ? parseFloat((totalSpend / numDaysToSimulate * factor).toFixed(2)) 
          : parseFloat((totalSpend - accumulatedSpend).toFixed(2));
          
        let dailyClicks = i < numDaysToSimulate - 1 
          ? Math.round(totalClicks / numDaysToSimulate * factor) 
          : totalClicks - accumulatedClicks;
          
        let dailyImpressions = i < numDaysToSimulate - 1 
          ? Math.round(totalImpressions / numDaysToSimulate * factor) 
          : totalImpressions - accumulatedImpressions;
        
        // Atualizar valores acumulados
        accumulatedSpend += dailySpend;
        accumulatedClicks += dailyClicks;
        accumulatedImpressions += dailyImpressions;
        
        processedInsights.push({
          date_start: dateString,
          spend: dailySpend.toString(),
          clicks: dailyClicks.toString(),
          impressions: dailyImpressions.toString()
        });
      }
      
      // Verificar que os totais são exatamente iguais aos valores da API
      const generatedSpendTotal = processedInsights.reduce((sum, insight) => 
        sum + safeParseFloat(insight.spend), 0);
      
      const generatedClicksTotal = processedInsights.reduce((sum, insight) => 
        sum + safeParseInt(insight.clicks), 0);
      
      const generatedImpressionsTotal = processedInsights.reduce((sum, insight) => 
        sum + safeParseInt(insight.impressions), 0);
      
      console.log(`Verificação de totais - API vs Gerado:
      Spend: ${totalSpend} vs ${generatedSpendTotal.toFixed(2)}
      Clicks: ${totalClicks} vs ${generatedClicksTotal}
      Impressions: ${totalImpressions} vs ${generatedImpressionsTotal}`);
      
      console.log('Created simulated daily data:', processedInsights);
    }
    
    // Tentativa de ordenar insights por data, mantendo ordem original se não houver datas
    try {
      processedInsights.sort((a, b) => {
        const dateA = extractDate(a);
        const dateB = extractDate(b);
        if (!dateA || !dateB) return 0;
        return new Date(dateA) - new Date(dateB);
      });
    } catch (err) {
      console.error('Error sorting insights by date:', err);
      // Manter a ordem original se houver erro
    }
    
    console.log('Sorted insights:', processedInsights);
    
    // Formatando as datas para os gráficos
    const labels = processedInsights.map((insight, index) => {
      const date = extractDate(insight);
      if (date) {
        try {
          const dateObj = new Date(date);
          const formattedDate = dateObj.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
          console.log(`Date for index ${index}:`, date, 'formatted as:', formattedDate);
          return formattedDate;
        } catch (err) {
          console.error('Error formatting date:', err);
        }
      }
      
      console.log(`No valid date found for index ${index}, using fallback`);
      return `Dia ${index + 1}`;
    });
    
    // Extrair dados para os gráficos com tratamento seguro de valores
    const spendValues = processedInsights.map(insight => {
      const value = safeParseFloat(insight.spend);
      console.log(`Spend for ${extractDate(insight) || 'unknown date'}:`, value);
      return value;
    });
    
    const clicksValues = processedInsights.map(insight => {
      const value = safeParseInt(insight.clicks);
      console.log(`Clicks for ${extractDate(insight) || 'unknown date'}:`, value);
      return value;
    });
    
    const impressionsValues = processedInsights.map(insight => {
      const value = safeParseInt(insight.impressions) / 1000;
      console.log(`Impressions/1000 for ${extractDate(insight) || 'unknown date'}:`, value);
      return value;
    });
    
    // Verificar se temos dados válidos para os gráficos
    console.log("Labels para gráficos:", labels);
    console.log("Dados de gastos:", spendValues);
    console.log("Dados de cliques:", clicksValues);
    console.log("Dados de impressões/1000:", impressionsValues);
    
    // Cores para gráficos
    const colors = {
      investment: {
        primary: 'rgb(220, 53, 69)',
        background: 'rgba(220, 53, 69, 0.1)',
      },
      clicks: {
        primary: 'rgb(25, 135, 84)',
        background: 'rgba(25, 135, 84, 0.1)',
      },
      impressions: {
        primary: 'rgb(13, 110, 253)',
        background: 'rgba(13, 110, 253, 0.1)',
      }
    };
    
    // Prepare data for investment trend chart (line chart)
    const spendData = {
      labels,
      datasets: [
        {
          label: 'Investimento (R$)',
          data: spendValues,
          borderColor: colors.investment.primary,
          backgroundColor: colors.investment.background,
          tension: 0.3,
          fill: true,
          pointRadius: 5,
          pointHoverRadius: 8,
          pointBackgroundColor: 'white',
          pointBorderColor: colors.investment.primary,
          pointBorderWidth: 2,
          borderWidth: 3,
        },
      ],
    };
    
    // Prepare data for performance chart (line chart)
    const performanceData = {
      labels,
      datasets: [
        {
          label: 'Cliques',
          data: clicksValues,
          borderColor: colors.clicks.primary,
          backgroundColor: colors.clicks.background,
          tension: 0.3,
          fill: false,
          pointRadius: 5,
          pointHoverRadius: 8,
          pointBackgroundColor: 'white',
          pointBorderColor: colors.clicks.primary,
          pointBorderWidth: 2,
          borderWidth: 3,
        },
        {
          label: 'Impressões (÷1000)',
          data: impressionsValues,
          borderColor: colors.impressions.primary,
          backgroundColor: colors.impressions.background,
          tension: 0.3,
          fill: false,
          pointRadius: 5,
          pointHoverRadius: 8,
          pointBackgroundColor: 'white',
          pointBorderColor: colors.impressions.primary,
          pointBorderWidth: 2,
          borderWidth: 3,
        },
      ],
    };
    
    return {
      spendData,
      performanceData,
    };
  };

  return (
    <Box
      sx={{
        flexGrow: 1,
        p: 3,
        maxWidth: '100vw',
        overflowX: 'hidden'
      }}
    >
      <Container maxWidth="xl" sx={{ mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Painel de Anúncios do Meta
        </Typography>
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        
        <Paper sx={{ p: 2, mb: 3, overflowX: 'auto' }}>
          <Grid container spacing={2}>
            <Grid item xs={12} md={3}>
              <FormControl fullWidth>
                <InputLabel>Business Manager</InputLabel>
                <Select
                  value={selectedBm}
                  onChange={(e) => setSelectedBm(e.target.value)}
                  label="Business Manager"
                >
                  {bmAccounts.map((bm) => (
                    <MenuItem key={bm} value={bm}>
                      {bm}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} md={3}>
              <FormControl fullWidth disabled={!selectedBm}>
                <InputLabel>Conta de Anúncio</InputLabel>
                <Select
                  value={selectedAdAccount}
                  onChange={(e) => setSelectedAdAccount(e.target.value)}
                  label="Conta de Anúncio"
                >
                  {adAccounts.map((account) => (
                    <MenuItem key={account.id} value={account.id}>
                      {account.name}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} md={3}>
              <FormControl fullWidth disabled={!selectedAdAccount}>
                <InputLabel>Campanha (Opcional)</InputLabel>
                <Select
                  value={selectedCampaign}
                  onChange={(e) => setSelectedCampaign(e.target.value)}
                  label="Campanha (Opcional)"
                >
                  <MenuItem value="">Todas as Campanhas</MenuItem>
                  {campaigns.map((campaign) => (
                    <MenuItem key={campaign.id} value={campaign.id}>
                      {campaign.name}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} md={3}>
              <FormControl fullWidth>
                <InputLabel>Período</InputLabel>
                <Select
                  value={useCustomDates ? "custom" : datePreset}
                  onChange={(e) => {
                    if (e.target.value === "custom") {
                      setUseCustomDates(true);
                    } else {
                      setUseCustomDates(false);
                      setDatePreset(e.target.value);
                    }
                  }}
                  label="Período"
                >
                  {datePresets.map((preset) => (
                    <MenuItem key={preset.value} value={preset.value}>
                      {preset.label}
                    </MenuItem>
                  ))}
                  <MenuItem value="custom">Data Personalizada</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            {useCustomDates && (
              <>
                <Grid item xs={12} md={3}>
                  <TextField
                    label="Data Inicial"
                    type="date"
                    value={startDate ? startDate.toISOString().split('T')[0] : ''}
                    onChange={(e) => {
                      const date = new Date(e.target.value);
                      setStartDate(date);
                    }}
                    InputLabelProps={{
                      shrink: true,
                    }}
                    fullWidth
                    helperText="DD/MM/AAAA"
                  />
                </Grid>
            
                <Grid item xs={12} md={3}>
                  <TextField
                    label="Data Final"
                    type="date"
                    value={endDate ? endDate.toISOString().split('T')[0] : ''}
                    onChange={(e) => {
                      const date = new Date(e.target.value);
                      setEndDate(date);
                    }}
                    InputLabelProps={{
                      shrink: true,
                    }}
                    fullWidth
                    helperText="DD/MM/AAAA"
                  />
                </Grid>
              </>
            )}
            
            <Grid item xs={12} md={useCustomDates ? 6 : 3}>
              <Button 
                variant="contained" 
                color="primary" 
                onClick={fetchInsights}
                disabled={!selectedAdAccount}
                fullWidth
                sx={{ height: '56px' }}
                startIcon={<FilterAltIcon />}
              >
                Carregar Dados
              </Button>
            </Grid>
          </Grid>
          
          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Box>
              <Button 
                variant="outlined" 
                onClick={() => setRegisterBmDialog(true)}
                sx={{ mr: 1 }}
              >
                Adicionar Business Manager
              </Button>
              
              <FormControl sx={{ minWidth: 170, ml: 1 }} size="small" variant="outlined">
                <InputLabel>Atualização</InputLabel>
                <Select
                  value={autoRefresh ? refreshInterval : "off"}
                  onChange={(e) => {
                    if (e.target.value === "off") {
                      setAutoRefresh(false);
                    } else {
                      setAutoRefresh(true);
                      setRefreshInterval(Number(e.target.value));
                    }
                  }}
                  label="Atualização"
                >
                  <MenuItem value="off">Desligada</MenuItem>
                  <MenuItem value="30">30 segundos</MenuItem>
                  <MenuItem value="60">1 minuto</MenuItem>
                  <MenuItem value="300">5 minutos</MenuItem>
                  <MenuItem value="600">10 minutos</MenuItem>
                </Select>
              </FormControl>
              
              {lastRefreshed && (
                <Typography variant="caption" sx={{ ml: 2, display: 'inline-block', color: 'text.secondary' }}>
                  Última atualização: {lastRefreshed.toLocaleTimeString('pt-BR')}
                </Typography>
              )}
            </Box>
            
            {insights && insights.length > 0 && (
              <Box>
                <Button
                  variant="contained"
                  startIcon={<DownloadIcon />}
                  onClick={generatePdf}
                  disabled={loading}
                  sx={{ mr: 1 }}
                >
                  Exportar PDF
                </Button>
                
                <Button
                  variant="contained"
                  color="secondary"
                  startIcon={<ShareIcon />}
                  onClick={handleShareDialogOpen}
                  disabled={loading}
                >
                  Compartilhar
                </Button>
              </Box>
            )}
          </Box>
        </Paper>
        
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', m: 3 }}>
            <CircularProgress />
          </Box>
        ) : insights && insights.length > 0 && chartData ? (
          <>
            <Grid container spacing={3} sx={{ mb: 3 }}>
              {/* KPI Cards */}
              <Grid item xs={12} sm={6} md={3}>
                <Paper
                  sx={{
                    p: 2,
                    display: 'flex',
                    flexDirection: 'column',
                    height: 140,
                    boxShadow: 3,
                    borderRadius: 2,
                    bgcolor: 'primary.lighter',
                  }}
                >
                  <Typography component="h2" variant="h6" color="primary" gutterBottom sx={{ fontWeight: 'bold' }}>
                    Impressões
                  </Typography>
                  <Typography component="p" variant="h4" sx={{ mt: 'auto', mb: 1 }}>
                    {totalImpressions.toLocaleString('pt-BR')}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Total no período selecionado
                  </Typography>
                </Paper>
              </Grid>
              
              <Grid item xs={12} sm={6} md={3}>
                <Paper
                  sx={{
                    p: 2,
                    display: 'flex',
                    flexDirection: 'column',
                    height: 140,
                    boxShadow: 3,
                    borderRadius: 2,
                    bgcolor: 'success.lighter',
                  }}
                >
                  <Typography component="h2" variant="h6" color="success.main" gutterBottom sx={{ fontWeight: 'bold' }}>
                    Cliques
                  </Typography>
                  <Typography component="p" variant="h4" sx={{ mt: 'auto', mb: 1 }}>
                    {totalClicks.toLocaleString('pt-BR')}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Total no período selecionado
                  </Typography>
                </Paper>
              </Grid>
              
              <Grid item xs={12} sm={6} md={3}>
                <Paper
                  sx={{
                    p: 2,
                    display: 'flex',
                    flexDirection: 'column',
                    height: 140,
                    boxShadow: 3,
                    borderRadius: 2,
                    bgcolor: 'warning.lighter',
                  }}
                >
                  <Typography component="h2" variant="h6" color="warning.main" gutterBottom sx={{ fontWeight: 'bold' }}>
                    CTR
                  </Typography>
                  <Typography component="p" variant="h4" sx={{ mt: 'auto', mb: 1 }}>
                    {ctr.toLocaleString('pt-BR', { style: 'percent', minimumFractionDigits: 2 })}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Taxa de cliques por impressão
                  </Typography>
                </Paper>
              </Grid>
              
              <Grid item xs={12} sm={6} md={3}>
                <Paper
                  sx={{
                    p: 2,
                    display: 'flex',
                    flexDirection: 'column',
                    height: 140,
                    boxShadow: 3,
                    borderRadius: 2,
                    bgcolor: 'error.lighter',
                  }}
                >
                  <Typography component="h2" variant="h6" color="error.main" gutterBottom sx={{ fontWeight: 'bold' }}>
                    Investimento
                  </Typography>
                  <Typography component="p" variant="h4" sx={{ mt: 'auto', mb: 1 }}>
                    {`R$ ${totalSpend.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Valor total investido no período
                  </Typography>
                </Paper>
              </Grid>
            </Grid>
              
            {/* Charts section */}
            <Grid container spacing={3}>
              {/* Line chart */}
              <Grid item xs={12} md={6}>
                <Paper sx={{ 
                  p: 2, 
                  display: 'flex', 
                  flexDirection: 'column', 
                  height: 350, 
                  overflowX: 'auto',
                  boxShadow: 2,
                  borderRadius: 2 
                }}>
                  <Typography variant="h6" gutterBottom sx={{ fontWeight: 'bold', color: 'error.main' }}>
                    Investimento ao Longo do Tempo
                  </Typography>
                  <Box sx={{ height: 300, flexGrow: 1, minWidth: '300px' }}>
                    {chartData?.spendData ? (
                      <Line 
                        data={chartData.spendData} 
                        options={{ 
                          responsive: true, 
                          maintainAspectRatio: false,
                          plugins: {
                            legend: {
                              display: true,
                              position: 'top',
                            },
                            tooltip: {
                              enabled: true,
                              mode: 'index',
                              intersect: false,
                              callbacks: {
                                label: function(context) {
                                  return `R$ ${context.raw.toLocaleString('pt-BR', {
                                    maximumFractionDigits: 2
                                  })}`;
                                }
                              }
                            }
                          },
                          scales: {
                            x: {
                              display: true,
                              title: {
                                display: true,
                                text: 'Data'
                              }
                            },
                            y: {
                              display: true,
                              title: {
                                display: true,
                                text: 'Valor (R$)'
                              },
                              ticks: {
                                callback: function(value) {
                                  return `R$ ${value.toLocaleString('pt-BR')}`;
                                }
                              }
                            }
                          }
                        }} 
                      />
                    ) : (
                      <Box display="flex" justifyContent="center" alignItems="center" height="100%">
                        <Typography variant="body2" color="text.secondary">
                          {loading ? 'Carregando dados...' : 'Nenhum dado disponível'}
                        </Typography>
                      </Box>
                    )}
                  </Box>
                </Paper>
              </Grid>
              
              {/* Line chart */}
              <Grid item xs={12} md={6}>
                <Paper sx={{ 
                  p: 2, 
                  display: 'flex', 
                  flexDirection: 'column', 
                  height: 350, 
                  overflowX: 'auto',
                  boxShadow: 2,
                  borderRadius: 2 
                }}>
                  <Typography variant="h6" gutterBottom sx={{ fontWeight: 'bold', color: 'primary.main' }}>
                    Desempenho da Campanha
                  </Typography>
                  <Box sx={{ height: 300, flexGrow: 1, minWidth: '300px' }}>
                    {chartData?.performanceData ? (
                      <Line 
                        data={chartData.performanceData} 
                        options={{ 
                          responsive: true, 
                          maintainAspectRatio: false,
                          plugins: {
                            legend: {
                              display: true,
                              position: 'top',
                            },
                            tooltip: {
                              enabled: true,
                              mode: 'index',
                              intersect: false,
                              callbacks: {
                                label: function(context) {
                                  const label = context.dataset.label || '';
                                  const value = context.raw;
                                  
                                  if (label.includes('Impressões')) {
                                    return `${label}: ${(value * 1000).toLocaleString('pt-BR')}`;
                                  }
                                  return `${label}: ${value.toLocaleString('pt-BR')}`;
                                }
                              }
                            }
                          },
                          scales: {
                            x: {
                              display: true,
                              title: {
                                display: true,
                                text: 'Data'
                              }
                            },
                            y: {
                              display: true,
                              title: {
                                display: true,
                                text: 'Valor'
                              }
                            }
                          }
                        }} 
                      />
                    ) : (
                      <Box display="flex" justifyContent="center" alignItems="center" height="100%">
                        <Typography variant="body2" color="text.secondary">
                          {loading ? 'Carregando dados...' : 'Nenhum dado disponível'}
                        </Typography>
                      </Box>
                    )}
                  </Box>
                </Paper>
              </Grid>
            </Grid>
              
            {/* DataGrid */}
            <Grid item xs={12} sx={{ mt: 3 }}>
              <Paper sx={{ 
                p: 2, 
                overflowX: 'auto', 
                maxWidth: '100%',
                boxShadow: 2,
                borderRadius: 2 
              }}>
                <Typography variant="h6" gutterBottom sx={{ fontWeight: 'bold' }}>
                  Dados Detalhados da Campanha
                </Typography>
                <Box sx={{ height: 400, width: '100%', overflow: 'auto' }}>
                  <DataGrid
                    rows={insights.map((insight, index) => ({ id: index, ...insight }))}
                    columns={(() => {
                      // Lista de colunas importantes/prioritárias
                      const priorityColumns = [
                        'date_start', 'date_stop', 'campaign_name', 'adset_name', 'ad_name',
                        'spend', 'impressions', 'clicks', 'ctr', 'cpc', 'reach', 
                        'frequency', 'conversions', 'cost_per_conversion'
                      ];
                      
                      // Mapeamento de nomes de colunas para português
                      const columnNameMap = {
                        'date_start': 'Data Inicial',
                        'date_stop': 'Data Final',
                        'campaign_name': 'Campanha',
                        'adset_name': 'Conjunto de Anúncios',
                        'ad_name': 'Anúncio',
                        'spend': 'Investimento (R$)',
                        'impressions': 'Impressões',
                        'clicks': 'Cliques',
                        'ctr': 'CTR',
                        'cpc': 'CPC (R$)',
                        'reach': 'Alcance',
                        'frequency': 'Frequência',
                        'conversions': 'Conversões',
                        'cost_per_conversion': 'Custo por Conversão (R$)'
                      };
                      
                      // Obter todas as colunas disponíveis
                      const availableColumns = insights.length > 0 ? Object.keys(insights[0] || {}) : [];
                      
                      // Filtrar colunas prioritárias que existem nos dados
                      const columnsToShow = priorityColumns.filter(col => 
                        availableColumns.includes(col)
                      );
                      
                      // Adicionar outras colunas importantes que podem não estar na lista prioritária
                      availableColumns.forEach(col => {
                        if (!columnsToShow.includes(col) && 
                            (col.includes('conversion') || 
                             col.includes('action') || 
                             col.includes('cost_per') || 
                             col.includes('value'))) {
                          columnsToShow.push(col);
                        }
                      });
                      
                      // Retornar configuração de colunas
                      return columnsToShow.map(key => ({
                        field: key,
                        headerName: columnNameMap[key] || key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' '),
                        width: 150,
                        flex: 1,
                        minWidth: 120,
                        valueFormatter: (params) => {
                          if (key.includes('cost_per') || key === 'cpc' || key === 'cpm' || key === 'spend') {
                            return `R$ ${parseFloat(params.value).toLocaleString('pt-BR', {
                              maximumFractionDigits: 2
                            })}`;
                          } else if (key === 'ctr' || key === 'frequency') {
                            return parseFloat(params.value).toLocaleString('pt-BR', {
                              style: key === 'ctr' ? 'percent' : 'decimal',
                              minimumFractionDigits: 2,
                              maximumFractionDigits: 2
                            });
                          } else if (key.includes('date')) {
                            // Formatar data para formato brasileiro
                            try {
                              const date = new Date(params.value);
                              return date.toLocaleDateString('pt-BR');
                            } catch (e) {
                              return params.value;
                            }
                          } else if (typeof params.value === 'number' || !isNaN(parseFloat(params.value))) {
                            return parseFloat(params.value).toLocaleString('pt-BR', {
                              maximumFractionDigits: 2
                            });
                          }
                          return params.value;
                        }
                      }));
                    })()}
                    autoHeight
                    disableColumnMenu
                    disableRowSelectionOnClick
                    pageSize={5}
                    rowsPerPageOptions={[5, 10, 25]}
                    pagination
                    localeText={{
                      // Tradução dos elementos da tabela
                      noRowsLabel: 'Nenhum dado encontrado',
                      footerRowSelected: count => `${count.toLocaleString()} linha${count !== 1 ? 's' : ''} selecionada${count !== 1 ? 's' : ''}`,
                      footerTotalRows: 'Total de linhas:',
                      footerTotalVisibleRows: (visibleCount, totalCount) => `${visibleCount.toLocaleString()} de ${totalCount.toLocaleString()}`,
                      MuiTablePagination: {
                        labelDisplayedRows: ({ from, to, count }) => `${from}–${to} de ${count !== -1 ? count : `mais de ${to}`}`,
                        labelRowsPerPage: 'Linhas por página:',
                      },
                    }}
                  />
                </Box>
              </Paper>
            </Grid>
            
            {/* Seção de Prévia dos Anúncios */}
            <Paper sx={{ p: 3, mt: 4, mb: 4, boxShadow: 3, borderRadius: 2 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                <Typography component="h2" variant="h5" color="primary" sx={{ fontWeight: 'bold' }}>
                  Prévia dos Anúncios
                </Typography>
                
                <FormControl variant="outlined" size="small" sx={{ minWidth: 150 }}>
                  <InputLabel id="ad-status-filter-label">Status</InputLabel>
                  <Select
                    labelId="ad-status-filter-label"
                    value={adStatusFilter}
                    onChange={(e) => {
                      const newFilter = e.target.value;
                      setAdStatusFilter(newFilter);
                      if (newFilter === 'ALL') {
                        setFilteredAds(ads);
                      } else {
                        setFilteredAds(ads.filter(ad => ad.status === newFilter));
                      }
                    }}
                    label="Status"
                  >
                    <MenuItem value="ALL">Todos</MenuItem>
                    <MenuItem value="ACTIVE">
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <CheckCircleIcon color="success" fontSize="small" sx={{ mr: 1 }} />
                        Ativos
                      </Box>
                    </MenuItem>
                    <MenuItem value="PAUSED">
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <PauseCircleIcon color="warning" fontSize="small" sx={{ mr: 1 }} />
                        Pausados
                      </Box>
                    </MenuItem>
                    <MenuItem value="DELETED">
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <BlockIcon color="error" fontSize="small" sx={{ mr: 1 }} />
                        Excluídos
                      </Box>
                    </MenuItem>
                  </Select>
                </FormControl>
              </Box>
              
              {adsLoading ? (
                <Box sx={{ display: 'flex', justifyContent: 'center', m: 3 }}>
                  <CircularProgress />
                </Box>
              ) : filteredAds && filteredAds.length > 0 ? (
                <>
                  <Grid container spacing={3}>
                    {filteredAds.map((ad) => (
                      <Grid item xs={12} sm={6} md={4} key={ad.id}>
                        <Paper
                          sx={{
                            p: 2,
                            display: 'flex',
                            flexDirection: 'column',
                            boxShadow: 2,
                            borderRadius: 2,
                            height: '100%'
                          }}
                        >
                          <Typography variant="h6" component="div" sx={{ mb: 1, fontWeight: 'bold' }}>
                            {ad.name}
                          </Typography>
                          <Box sx={{ mb: 2 }}>
                            <Chip 
                              label={ad.status} 
                              color={
                                ad.status === 'ACTIVE' ? 'success' : 
                                ad.status === 'PAUSED' ? 'warning' :
                                ad.status === 'DELETED' ? 'error' : 'default'
                              }
                              size="small"
                              sx={{ mr: 1 }}
                              icon={
                                ad.status === 'ACTIVE' ? <CheckCircleIcon /> : 
                                ad.status === 'PAUSED' ? <PauseCircleIcon /> :
                                ad.status === 'DELETED' ? <BlockIcon /> : <HelpIcon />
                              }
                            />
                          </Box>
                          <Divider sx={{ my: 1 }} />
                          {ad.preview_link ? (
                            <Box sx={{ mt: 2, textAlign: 'center' }}>
                              <Button 
                                variant="contained" 
                                color="primary" 
                                href={ad.preview_link} 
                                target="_blank"
                                fullWidth
                              >
                                Ver Anúncio
                              </Button>
                            </Box>
                          ) : ad.preview_html ? (
                            <Box 
                              sx={{ 
                                mt: 2, 
                                p: 1, 
                                border: '1px solid #e0e0e0', 
                                borderRadius: 1,
                                maxHeight: '300px',
                                overflow: 'auto'
                              }}
                              dangerouslySetInnerHTML={{ __html: ad.preview_html }}
                            />
                          ) : (
                            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
                              Prévia não disponível para este anúncio
                            </Typography>
                          )}
                        </Paper>
                      </Grid>
                    ))}
                  </Grid>
                  
                  <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
                    <Button 
                      variant="outlined" 
                      color="primary"
                      onClick={fetchAds}
                    >
                      Atualizar Anúncios
                    </Button>
                  </Box>
                </>
              ) : (
                <Alert severity="info" sx={{ mt: 2 }}>
                  Nenhum anúncio encontrado para a seleção atual. Isso pode acontecer se não houver anúncios ativos ou se os anúncios estiverem em revisão.
                </Alert>
              )}
            </Paper>
          </>
        ) : (
          <Paper sx={{ p: 4, textAlign: 'center', borderRadius: 2, boxShadow: 2 }}>
            <Typography variant="h6" color="text.secondary">
              Selecione os filtros acima para visualizar os dados
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              Você precisa selecionar pelo menos uma Business Manager e uma Conta de Anúncio
            </Typography>
          </Paper>
        )}
        
        {/* Register BM Dialog */}
        <Dialog open={registerBmDialog} onClose={() => setRegisterBmDialog(false)}>
          <DialogTitle>Adicionar Business Manager</DialogTitle>
          <DialogContent>
            <DialogContentText>
              Adicione uma nova conta de Business Manager do Meta para analisar seus dados de anúncios.
            </DialogContentText>
            <TextField
              autoFocus
              margin="dense"
              label="Business Manager ID"
              fullWidth
              variant="outlined"
              value={newBmId}
              onChange={(e) => setNewBmId(e.target.value)}
            />
            <TextField
              margin="dense"
              label="Access Token"
              fullWidth
              variant="outlined"
              value={newBmToken}
              onChange={(e) => setNewBmToken(e.target.value)}
            />
            <DialogContentText sx={{ mt: 2, fontSize: '0.875rem' }}>
              Para obter seu access token, acesse <a href="https://developers.facebook.com/tools/explorer/" target="_blank" rel="noopener noreferrer">Graph API Explorer</a> e selecione as permissões: ads_read, ads_management.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setRegisterBmDialog(false)}>Cancelar</Button>
            <Button 
              onClick={registerNewBm} 
              variant="contained"
              disabled={loading}
            >
              {loading ? <CircularProgress size={24} /> : 'Adicionar'}
            </Button>
          </DialogActions>
        </Dialog>
        
        {/* Share Dialog */}
        <Dialog open={shareDialog} onClose={handleShareDialogClose}>
          <DialogTitle>Compartilhar Relatório</DialogTitle>
          <DialogContent>
            <DialogContentText>
              Gere um link para compartilhar este relatório com outras pessoas.
            </DialogContentText>
            <TextField
              margin="dense"
              label="Expiração (horas)"
              type="number"
              fullWidth
              variant="outlined"
              value={shareExpiration}
              onChange={(e) => setShareExpiration(e.target.value)}
              sx={{ mb: 2 }}
            />
            {shareLink && (
              <TextField
                margin="dense"
                label="Link de Compartilhamento"
                fullWidth
                variant="outlined"
                value={shareLink}
                InputProps={{
                  readOnly: true,
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        onClick={() => {
                          navigator.clipboard.writeText(shareLink);
                          setCopied(true);
                          setTimeout(() => setCopied(false), 2000);
                        }}
                      >
                        {copied ? <CheckIcon color="success" /> : <ContentCopyIcon />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={handleShareDialogClose}>Fechar</Button>
            {!shareLink && (
              <Button 
                onClick={createShareLink} 
                variant="contained"
                disabled={loading}
              >
                {loading ? <CircularProgress size={24} /> : 'Gerar Link'}
              </Button>
            )}
          </DialogActions>
        </Dialog>
      </Container>
    </Box>
  );
}

export default Dashboard;
